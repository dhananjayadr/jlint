#!/bin/bash

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Get all *.jmx files that are being committed
jmx_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.jmx$')

# Exit early if no JMX files are being committed
if [ -z "$jmx_files" ]; then
    echo -e "${GREEN}No JMeter scripts (*.jmx) found in commit. Skipping validation.${NC}"
    exit 0
fi

echo -e "${YELLOW}==== JMeter Script Validator ====${NC}"
echo -e "Found $(echo "$jmx_files" | wc -l | tr -d ' ') JMeter scripts to validate."

# Initialize counters
total_files=$(echo "$jmx_files" | wc -l | tr -d ' ')
files_passed=0
files_with_issues=()

# Process each JMX file
while IFS= read -r file; do
    [ -z "$file" ] && continue
    
    echo -e "\n${YELLOW}Checking: ${CYAN}$file${NC}"
    
    # Initialize variables for this file
    file_passed=true
    issues_found=()
    
    # Skip if file doesn't exist or isn't readable
    if [ ! -f "$file" ] || [ ! -r "$file" ]; then
        echo -e "${RED}Error: File '$file' not found or not readable.${NC}"
        files_with_issues+=("$file (not found/readable)")
        continue
    fi
    
    # Run validation with single AWK pass
    validation_results=$(awk '
    BEGIN {
        v1_fail = 0; v2_fail = 0; v3_fail = 0;
        v1_issues = ""; v2_issues = ""; v3_issues = "";
    }

    /<stringProp/ {
        content = $0;
        sub(/.*<stringProp[^>]*>/, "", content);
        sub(/<\/stringProp>.*/, "", content);
        
        # HTML decode common entities
        gsub(/&quot;/, "\"", content);
        gsub(/&amp;/, "&", content);
        gsub(/&lt;/, "<", content);
        gsub(/&gt;/, ">", content);
        
        # VALIDATION 1: Simple Property References Check
        if (content ~ /\$\{[^_][^_]?[^P]?[^(]?/ || content ~ /\$\{[^(]/) {
            open_count = 0; close_count = 0;
            len = length(content);
            for (i = 1; i <= len; i++) {
                if (substr(content, i, 2) == "${" && 
                    !(substr(content, i, 5) == "${__P" || 
                      substr(content, i, 6) == "${__V2" ||
                      substr(content, i, 7) == "${__BeanShell" ||
                      substr(content, i, 6) == "${__JSR" ||
                      substr(content, i, 6) == "${__jm" ||
                      substr(content, i, 6) == "${__Random")) {
                    open_count++;
                    i++;
                }
                else if (substr(content, i, 1) == "}") {
                    close_count++;
                }
            }
            
            if (open_count > close_count) {
                v1_fail = 1;
                v1_issues = v1_issues substr(content, 1, 60) "...\n";
            }
        }
        
        # VALIDATION 2: __P Function Calls Check
        if (content ~ /\$\{__P\(/) {
            p_func_start = 0; p_func_end = 0; close_brace = 0;
            len = length(content);
            for (i = 1; i <= len; i++) {
                if (substr(content, i, 6) == "${__P(") {
                    p_func_start++;
                    i += 5;
                }
                else if (substr(content, i, 1) == "}" && i > 1 && substr(content, i-1, 1) == ")") {
                    p_func_end++;
                }
                else if (substr(content, i, 1) == "}") {
                    close_brace++;
                }
            }
            
            if (p_func_start > p_func_end && p_func_start > close_brace) {
                v2_fail = 1;
                v2_issues = v2_issues substr(content, 1, 60) "...\n";
            }
        }
        
        # VALIDATION 3: JSON with JMeter Variables Check
        if (content ~ /\$\{/ && (content ~ /[\[\]{},]/ || content ~ /":/)) {
            orig = content;
            open_brace = gsub(/\{/, "{", content);
            close_brace = gsub(/\}/, "}", content);
            open_bracket = gsub(/\[/, "[", content);
            close_bracket = gsub(/\]/, "]", content);
            
            if (open_brace != close_brace) {
                v3_fail = 1;
                v3_issues = v3_issues "JSON_BRACE::" substr(orig, 1, 60) "...\n";
            }
            if (open_bracket != close_bracket) {
                v3_fail = 1;
                v3_issues = v3_issues "BRACKET::" substr(orig, 1, 60) "...\n";
            }
            if (orig ~ /\$\{[^\}]*$/) {
                v3_fail = 1;
                v3_issues = v3_issues "UNCLOSED_VAR::" substr(orig, 1, 60) "...\n";
            }
        }
    }

    END {
        print "V1_FAIL=" v1_fail;
        print "V1_ISSUES=" v1_issues;
        print "V2_FAIL=" v2_fail;
        print "V2_ISSUES=" v2_issues;
        print "V3_FAIL=" v3_fail;
        print "V3_ISSUES=" v3_issues;
    }' "$file")
    
    # Extract validation results
    v1_fail=$(echo "$validation_results" | grep -m1 "^V1_FAIL=" | cut -d= -f2)
    v1_issues=$(echo "$validation_results" | sed -n 's/^V1_ISSUES=//p')
    v2_fail=$(echo "$validation_results" | grep -m1 "^V2_FAIL=" | cut -d= -f2)
    v2_issues=$(echo "$validation_results" | sed -n 's/^V2_ISSUES=//p')
    v3_fail=$(echo "$validation_results" | grep -m1 "^V3_FAIL=" | cut -d= -f2)
    v3_issues=$(echo "$validation_results" | sed -n 's/^V3_ISSUES=//p')
    
    # Check validation 1
    if [ "$v1_fail" -eq 1 ]; then
        echo -e "${RED}✖ FAIL:${NC} Unclosed simple property references found"
        echo -e "$v1_issues"
        issues_found+=("unclosed simple property references")
        file_passed=false
    fi
    
    # Check validation 2
    if [ "$v2_fail" -eq 1 ]; then
        echo -e "${RED}✖ FAIL:${NC} Unclosed __P function calls found"
        echo -e "$v2_issues"
        issues_found+=("unclosed __P function calls")
        file_passed=false
    fi
    
    # Check validation 3
    if [ "$v3_fail" -eq 1 ]; then
        echo -e "${RED}✖ FAIL:${NC} JSON structure issues found"
        echo "$v3_issues" | while IFS= read -r line; do
            if [ -n "$line" ]; then
                issue_type="${line%%::*}"
                content="${line#*::}"
                echo "- [$issue_type] $content"
            fi
        done
        issues_found+=("JSON structure issues")
        file_passed=false
    fi
    
    # File summary
    if $file_passed; then
        echo -e "${GREEN}✓ PASS:${NC} No issues found"
        files_passed=$((files_passed + 1))
    else
        files_with_issues+=("$file (${issues_found[*]})")
    fi
    
done <<< "$jmx_files"

# Print overall summary
echo -e "\n${YELLOW}==== VALIDATION SUMMARY ====${NC}"
echo -e "Total files: $total_files"
echo -e "Files passed: ${GREEN}$files_passed${NC}"
echo -e "Files with issues: ${RED}$((total_files - files_passed))${NC}"

if [ ${#files_with_issues[@]} -gt 0 ]; then
    echo -e "\n${RED}Files with issues:${NC}"
    for issue in "${files_with_issues[@]}"; do
        echo -e "- $issue"
    done
    echo -e "\n${YELLOW}Commit rejected. Please fix JMeter script issues before committing.${NC}"
    exit 1
else
    echo -e "\n${GREEN}All JMeter scripts passed validation!${NC}"
    exit 0
fi
